<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Drive PLY Browser</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4caf50;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-indicator.offline { background: #f44336; animation: none; }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        
        .main-container {
            flex: 1;
            display: flex;
            margin: 20px;
            gap: 20px;
            min-height: 0;
        }
        
        .sidebar {
            width: 350px;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-count {
            background: rgba(255,255,255,0.2);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 13px;
        }
        
        .file-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .file-item {
            padding: 15px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            position: relative;
        }
        
        .file-item:hover { background: #e9ecef; transform: translateX(5px); }
        .file-item:hover .delete-btn { opacity: 1; }
        .file-item.selected { background: #e7eaff; border-color: #667eea; }
        
        .file-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
            font-size: 14px;
            padding-right: 30px;
        }
        
        .file-info {
            font-size: 12px;
            color: #666;
            line-height: 1.5;
        }
        
        .delete-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #f44336;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            opacity: 0;
            transition: all 0.2s;
            padding: 0;
        }
        
        .delete-btn:hover { background: #d32f2f; transform: scale(1.1); }
        
        .viewer-container {
            flex: 1;
            position: relative;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        #viewer { width: 100%; height: 100%; }
        
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            max-width: 250px;
        }
        
        .info-panel h3 { margin-bottom: 10px; font-size: 16px; }
        .info-item { margin: 5px 0; }
        
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .zoom-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.5);
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .zoom-btn:hover {
            background: rgba(118, 75, 162, 0.95);
            border-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.15);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        .reset-btn {
            font-size: 20px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            min-width: 250px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-message {
            margin-top: 10px;
            font-size: 14px;
            color: #667eea;
        }
        
        .progress-text {
            margin-top: 10px;
            font-weight: 600;
            color: #667eea;
        }
        
        .upload-progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-top: 15px;
            overflow: hidden;
        }
        
        .upload-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .error {
            color: #e74c3c;
            padding: 10px;
            background: #ffebee;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .upload-section {
            padding: 15px;
            border-bottom: 1px solid #eee;
        }
        
        input[type="file"] { display: none; }
        
        .upload-btn {
            width: 100%;
            background: #4caf50;
        }
        
        .upload-btn:hover { background: #45a049; }
        
        .storage-info {
            padding: 15px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            font-size: 12px;
            color: #666;
        }
        
        .progress-bar {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.show { display: flex; }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .modal-content h3 { color: #333; margin-bottom: 15px; font-size: 20px; }
        .modal-content p { color: #666; margin-bottom: 25px; line-height: 1.5; }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .btn-cancel { background: #9e9e9e; }
        .btn-cancel:hover { background: #757575; }
        .btn-delete { background: #f44336; }
        .btn-delete:hover { background: #d32f2f; }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            <span class="status-indicator" id="statusIndicator"></span>
            🎨 Google Drive PLY Browser
        </h1>
        <div class="controls">
            <button onclick="refreshFileList()">🔄 Refresh</button>
            <button onclick="document.getElementById('fileInput').click()">⬆️ Upload PLY</button>
            <span id="connectionStatus" style="margin-left: 10px; color: #666;"></span>
        </div>
        <div id="errorMsg"></div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <span>PLY Files</span>
                <span class="file-count" id="fileCount">0 files</span>
            </div>
            
            <div class="upload-section">
                <input type="file" id="fileInput" accept=".ply" onchange="uploadFile()">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    📁 Choose PLY File
                </button>
            </div>
            
            <div class="file-list" id="fileList">
                <div class="empty-state">
                    <div class="empty-state-icon">📦</div>
                    <div>No PLY files found</div>
                    <div style="font-size: 12px; margin-top: 5px;">Upload a file to get started</div>
                </div>
            </div>
            
            <div class="storage-info" id="storageInfo">Checking storage...</div>
        </div>
        
        <div class="viewer-container">
            <div id="viewer"></div>
            <div class="info-panel" id="infoPanel" style="display: none;">
                <h3>Model Info</h3>
                <div class="info-item">Vertices: <span id="vertexCount">-</span></div>
                <div class="info-item">Faces: <span id="faceCount">-</span></div>
                <div class="info-item">Has Colors: <span id="hasColors">-</span></div>
                <div class="info-item">File Size: <span id="fileSize">-</span></div>
            </div>
            
            <!-- Zoom Controls -->
            <div class="zoom-controls" id="zoomControls">
                <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
                <button class="zoom-btn reset-btn" onclick="resetView()" title="Reset View">⟲</button>
                <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">−</button>
                <button class="zoom-btn" onclick="increasePointSize()" title="Larger Points" style="font-size: 16px;">●+</button>
                <button class="zoom-btn" onclick="decreasePointSize()" title="Smaller Points" style="font-size: 16px;">●−</button>
            </div>
            
            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <div class="loading-message" id="loadingMessage">Loading 3D model...</div>
                <div class="progress-text" id="progressText"></div>
                <div class="upload-progress-bar" id="uploadProgressBar" style="display: none;">
                    <div class="upload-progress-fill" id="uploadProgressFill"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="deleteModal">
        <div class="modal-content">
            <h3>⚠️ Confirm Delete</h3>
            <p>Are you sure you want to delete <strong id="deleteFileName"></strong>?</p>
            <p style="font-size: 13px; color: #f44336;">This action cannot be undone.</p>
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeDeleteModal()">Cancel</button>
                <button class="btn-delete" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const API_URL = 'http://localhost:8000';
        let scene, camera, renderer, currentMesh, selectedFileName = null, fileToDelete = null;
        let initialCameraPosition = { x: 0, y: 0, z: 5 };
        let currentRotation = { x: 0, y: 0 };
        let currentPointSize = 0.1;
        
        function increasePointSize() {
            if (currentMesh && currentMesh.material && currentMesh.material.size !== undefined) {
                currentPointSize = Math.min(1.0, currentPointSize * 1.2);
                currentMesh.material.size = currentPointSize;
                currentMesh.material.needsUpdate = true;
                console.log('Point size:', currentPointSize);
            }
        }
        
        function decreasePointSize() {
            if (currentMesh && currentMesh.material && currentMesh.material.size !== undefined) {
                currentPointSize = Math.max(0.001, currentPointSize * 0.8);
                currentMesh.material.size = currentPointSize;
                currentMesh.material.needsUpdate = true;
                console.log('Point size:', currentPointSize);
            }
        }
        
        function initScene() {
            const container = document.getElementById('viewer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);  // Dark background for point clouds
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 5;
            initialCameraPosition = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 0.6);
            light.position.set(10, 10, 10);
            scene.add(light);
            
            let isDragging = false, prevMouse = { x: 0, y: 0 };
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging && currentMesh) {
                    const deltaX = (e.clientX - prevMouse.x) * 0.01;
                    const deltaY = (e.clientY - prevMouse.y) * 0.01;
                    currentMesh.rotation.y += deltaX;
                    currentMesh.rotation.x += deltaY;
                    currentRotation.y = currentMesh.rotation.y;
                    currentRotation.x = currentMesh.rotation.x;
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z = Math.max(0.5, Math.min(100, camera.position.z + e.deltaY * 0.01));
            });
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function zoomIn() {
            camera.position.z = Math.max(0.5, camera.position.z - 0.5);
        }
        
        function zoomOut() {
            camera.position.z = Math.min(100, camera.position.z + 0.5);
        }
        
        function resetView() {
            // Reset camera position
            camera.position.set(initialCameraPosition.x, initialCameraPosition.y, initialCameraPosition.z);
            
            // Reset mesh rotation
            if (currentMesh) {
                currentMesh.rotation.set(0, 0, 0);
                currentRotation = { x: 0, y: 0 };
            }
        }
        
        async function checkConnection() {
            try {
                const response = await fetch(`${API_URL}/`);
                if (response.ok) {
                    updateConnectionStatus(true);
                    return true;
                }
            } catch (error) {
                updateConnectionStatus(false);
                return false;
            }
        }
        
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('statusIndicator');
            const status = document.getElementById('connectionStatus');
            if (connected) {
                indicator.classList.remove('offline');
                status.textContent = 'Connected';
                status.style.color = '#4caf50';
            } else {
                indicator.classList.add('offline');
                status.textContent = 'Server Offline';
                status.style.color = '#f44336';
            }
        }
        
        async function loadFileList() {
            try {
                const response = await fetch(`${API_URL}/api/list-ply-files`);
                const data = await response.json();
                if (data.success) {
                    displayFileList(data.files);
                    document.getElementById('fileCount').textContent = `${data.count} file${data.count !== 1 ? 's' : ''}`;
                } else {
                    showError('Failed to load file list: ' + data.error);
                }
            } catch (error) {
                showError('Cannot connect to server. Make sure Flask is running on http://localhost:5000');
                updateConnectionStatus(false);
            }
        }
        
        function displayFileList(files) {
            const fileList = document.getElementById('fileList');
            if (files.length === 0) {
                fileList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">📦</div><div>No PLY files found</div></div>';
                return;
            }
            fileList.innerHTML = files.map(file => {
                const name = file.name.replace(/'/g, "\\'");
                return `
                    <div class="file-item" onclick="loadPLYFile('${name}', event)">
                        <button class="delete-btn" onclick="event.stopPropagation(); showDeleteModal('${name}');">×</button>
                        <div class="file-name">📄 ${file.display_name}</div>
                        <div class="file-info">
                            ${file.vertex_count.toLocaleString()} vertices<br>
                            ${file.face_count.toLocaleString()} faces<br>
                            ${file.file_size_mb.toFixed(2)} MB${file.has_color ? ' • 🎨' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        async function loadPLYFile(name, event) {
            showLoading(true, 'Loading 3D model...');
            clearError();
            selectedFileName = name;
            
            document.querySelectorAll('.file-item').forEach(item => item.classList.remove('selected'));
            if (event && event.currentTarget) event.currentTarget.classList.add('selected');
            
            try {
                const response = await fetch(`${API_URL}/api/download-ply/${name}`);
                if (!response.ok) throw new Error('Failed to download file');
                
                const arrayBuffer = await response.arrayBuffer();
                const plyData = parsePLY(arrayBuffer);
                displayPLY(plyData, arrayBuffer.byteLength);
            } catch (error) {
                showError(`Error loading file: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }
        
        function parsePLY(arrayBuffer) {
            // Convert to text to read header
            const decoder = new TextDecoder('ascii');
            const headerText = decoder.decode(arrayBuffer.slice(0, Math.min(10000, arrayBuffer.byteLength)));
            const lines = headerText.split('\n');
            
            if (!lines[0] || lines[0].trim() !== 'ply') {
                throw new Error('Not a valid PLY file');
            }
            
            let format = 'ascii';
            let vertexCount = 0, faceCount = 0, headerEnd = 0;
            let hasColor = false, hasNormals = false;
            let properties = [];
            
            // Parse header
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('format')) {
                    format = line.split(/\s+/)[1];
                }
                if (line.startsWith('element vertex')) {
                    vertexCount = parseInt(line.split(/\s+/)[2]);
                }
                if (line.startsWith('element face')) {
                    faceCount = parseInt(line.split(/\s+/)[2]);
                }
                if (line.startsWith('property')) {
                    properties.push(line);
                    if (line.includes('red') || line.includes('green')) hasColor = true;
                    if (line.includes('nx') || line.includes('ny')) hasNormals = true;
                }
                if (line === 'end_header') {
                    // Find byte position of end_header
                    const headerBytes = new TextEncoder().encode(lines.slice(0, i + 1).join('\n') + '\n');
                    headerEnd = headerBytes.length;
                    break;
                }
            }
            
            console.log(`Format: ${format}, Vertices: ${vertexCount}, Faces: ${faceCount}`);
            
            if (format === 'ascii') {
                return parsePLY_ASCII(arrayBuffer, headerEnd, vertexCount, faceCount, hasColor, properties);
            } else if (format.startsWith('binary')) {
                return parsePLY_Binary(arrayBuffer, headerEnd, vertexCount, faceCount, hasColor, hasNormals, format, properties);
            } else {
                throw new Error(`Unsupported PLY format: ${format}`);
            }
        }
        
        function parsePLY_ASCII(arrayBuffer, headerEnd, vertexCount, faceCount, hasColor, properties) {
            const decoder = new TextDecoder('ascii');
            const text = decoder.decode(arrayBuffer);
            const lines = text.split('\n');
            
            // Find where header ends in lines
            let lineStart = 0;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim() === 'end_header') {
                    lineStart = i + 1;
                    break;
                }
            }
            
            const vertices = [], colors = [], indices = [];
            
            // Parse vertices
            for (let i = 0; i < vertexCount; i++) {
                const parts = lines[lineStart + i].trim().split(/\s+/);
                vertices.push(parseFloat(parts[0]), parseFloat(parts[1]), parseFloat(parts[2]));
                
                if (hasColor && parts.length >= 6) {
                    colors.push(parseInt(parts[3])/255, parseInt(parts[4])/255, parseInt(parts[5])/255);
                }
            }
            
            // Parse faces
            const faceStart = lineStart + vertexCount;
            for (let i = 0; i < faceCount; i++) {
                const parts = lines[faceStart + i].trim().split(/\s+/);
                const nVerts = parseInt(parts[0]);
                if (nVerts === 3) {
                    indices.push(parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3]));
                } else if (nVerts === 4) {
                    const [v0,v1,v2,v3] = [parseInt(parts[1]),parseInt(parts[2]),parseInt(parts[3]),parseInt(parts[4])];
                    indices.push(v0,v1,v2,v0,v2,v3);
                }
            }
            
            return {
                vertices: new Float32Array(vertices),
                colors: hasColor && colors.length ? new Float32Array(colors) : null,
                indices: new Uint32Array(indices),
                vertexCount: vertices.length / 3,
                faceCount: indices.length / 3,
                hasColor: hasColor && colors.length > 0
            };
        }
        
        function parsePLY_Binary(arrayBuffer, headerEnd, vertexCount, faceCount, hasColor, hasNormals, format, properties) {
            const littleEndian = format.includes('little');
            const view = new DataView(arrayBuffer, headerEnd);
            
            console.log('Parsing binary PLY...');
            console.log('Properties:', properties);
            
            // Determine vertex format from properties
            let vertexSize = 0;
            let xOffset = 0, yOffset = 4, zOffset = 8;
            let colorOffset = -1;
            let normalOffset = -1;
            
            let currentOffset = 0;
            for (let prop of properties) {
                if (prop.includes('float') && prop.includes(' x')) {
                    xOffset = currentOffset;
                    currentOffset += 4;
                } else if (prop.includes('float') && prop.includes(' y')) {
                    yOffset = currentOffset;
                    currentOffset += 4;
                } else if (prop.includes('float') && prop.includes(' z')) {
                    zOffset = currentOffset;
                    currentOffset += 4;
                } else if (prop.includes('float') && prop.includes('nx')) {
                    normalOffset = currentOffset;
                    currentOffset += 4;
                } else if (prop.includes('float') && prop.includes('ny')) {
                    currentOffset += 4;
                } else if (prop.includes('float') && prop.includes('nz')) {
                    currentOffset += 4;
                } else if (prop.includes('uchar') && (prop.includes('red') || prop.includes('diffuse_red'))) {
                    colorOffset = currentOffset;
                    currentOffset += 1;
                } else if (prop.includes('uchar') && (prop.includes('green') || prop.includes('diffuse_green'))) {
                    currentOffset += 1;
                } else if (prop.includes('uchar') && (prop.includes('blue') || prop.includes('diffuse_blue'))) {
                    currentOffset += 1;
                } else if (prop.includes('uchar') && (prop.includes('alpha') || prop.includes('diffuse_alpha'))) {
                    currentOffset += 1;
                } else if (prop.includes('float')) {
                    currentOffset += 4;
                } else if (prop.includes('uchar')) {
                    currentOffset += 1;
                } else if (prop.includes('int')) {
                    currentOffset += 4;
                }
            }
            
            vertexSize = currentOffset;
            console.log(`Vertex size: ${vertexSize} bytes, Color offset: ${colorOffset}`);
            
            const vertices = [];
            const colors = [];
            let offset = 0;
            
            // Parse vertices
            for (let i = 0; i < vertexCount; i++) {
                // Read x, y, z
                const x = view.getFloat32(offset + xOffset, littleEndian);
                const y = view.getFloat32(offset + yOffset, littleEndian);
                const z = view.getFloat32(offset + zOffset, littleEndian);
                vertices.push(x, y, z);
                
                // Read colors if present
                if (colorOffset >= 0) {
                    const r = view.getUint8(offset + colorOffset);
                    const g = view.getUint8(offset + colorOffset + 1);
                    const b = view.getUint8(offset + colorOffset + 2);
                    colors.push(r/255, g/255, b/255);
                }
                
                offset += vertexSize;
            }
            
            console.log(`Parsed ${vertices.length/3} vertices, ${colors.length/3} colors`);
            
            // Parse faces
            const indices = [];
            for (let i = 0; i < faceCount; i++) {
                const nVerts = view.getUint8(offset);
                offset += 1;
                
                if (nVerts === 3) {
                    const v0 = view.getInt32(offset, littleEndian);
                    const v1 = view.getInt32(offset + 4, littleEndian);
                    const v2 = view.getInt32(offset + 8, littleEndian);
                    indices.push(v0, v1, v2);
                    offset += 12;
                } else if (nVerts === 4) {
                    const v0 = view.getInt32(offset, littleEndian);
                    const v1 = view.getInt32(offset + 4, littleEndian);
                    const v2 = view.getInt32(offset + 8, littleEndian);
                    const v3 = view.getInt32(offset + 12, littleEndian);
                    indices.push(v0, v1, v2, v0, v2, v3);
                    offset += 16;
                } else {
                    // Skip unsupported face types
                    offset += nVerts * 4;
                }
            }
            
            console.log(`Parsed binary PLY: ${vertices.length/3} vertices, ${indices.length/3} faces, has colors: ${colors.length > 0}`);
            
            return {
                vertices: new Float32Array(vertices),
                colors: colors.length > 0 ? new Float32Array(colors) : null,
                indices: new Uint32Array(indices),
                vertexCount: vertices.length / 3,
                faceCount: indices.length / 3,
                hasColor: colors.length > 0
            };
        }
        
        function displayPLY(plyData, fileSize) {
            if (currentMesh) scene.remove(currentMesh);
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(plyData.vertices, 3));
            if (plyData.indices.length) geometry.setIndex(new THREE.BufferAttribute(plyData.indices, 1));
            if (plyData.colors) geometry.setAttribute('color', new THREE.BufferAttribute(plyData.colors, 3));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: plyData.hasColor,
                side: THREE.DoubleSide
            });
            if (!plyData.hasColor) material.color.setHex(0x4a90e2);
            
            currentMesh = new THREE.Mesh(geometry, material);
            scene.add(currentMesh);
            
            const bbox = geometry.boundingBox || geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            currentMesh.position.sub(center);
            
            const size = geometry.boundingBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            currentMesh.scale.setScalar(3 / maxDim);
            
            document.getElementById('vertexCount').textContent = plyData.vertexCount.toLocaleString();
            document.getElementById('faceCount').textContent = plyData.faceCount.toLocaleString();
            document.getElementById('hasColors').textContent = plyData.hasColor ? 'Yes' : 'No';
            document.getElementById('fileSize').textContent = `${(fileSize / 1024 / 1024).toFixed(2)} MB`;
            document.getElementById('infoPanel').style.display = 'block';
        }
        
        async function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) return;
            
            const sizeMB = file.size / (1024 * 1024);
            if (sizeMB > 50 && !confirm(`File is ${sizeMB.toFixed(1)} MB. Large files may take time. Continue?`)) {
                fileInput.value = '';
                return;
            }
            
            showLoading(true, `Uploading ${file.name}...`);
            setProgress(0);
            clearError();
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('name', file.name.replace('.ply', ''));
            
            try {
                const result = await uploadWithProgress(formData);
                if (result.success) {
                    await refreshFileList();
                    const msg = result.vertices 
                        ? `✅ Uploaded! ${result.vertices.toLocaleString()} vertices, ${result.faces.toLocaleString()} faces`
                        : '✅ File uploaded successfully!';
                    showError(msg, false);
                } else {
                    showError('Upload failed: ' + result.error);
                }
            } catch (error) {
                showError('Upload error: ' + error.message);
            } finally {
                showLoading(false);
                fileInput.value = '';
            }
        }
        
        function uploadWithProgress(formData) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const pct = (e.loaded / e.total) * 100;
                        setProgress(pct);
                        showLoading(true, `Uploading: ${(e.loaded/1024/1024).toFixed(1)} / ${(e.total/1024/1024).toFixed(1)} MB`);
                    }
                });
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try { resolve(JSON.parse(xhr.responseText)); }
                        catch (e) { reject(new Error('Invalid response')); }
                    } else {
                        try { reject(new Error(JSON.parse(xhr.responseText).error || 'Upload failed')); }
                        catch (e) { reject(new Error(`Upload failed: ${xhr.status}`)); }
                    }
                });
                xhr.addEventListener('error', () => reject(new Error('Network error')));
                xhr.open('POST', `${API_URL}/api/upload-ply`);
                xhr.timeout = 600000;
                xhr.send(formData);
            });
        }
        
        function showDeleteModal(name) {
            if (!name || name === 'undefined') return;
            fileToDelete = name;
            document.getElementById('deleteFileName').textContent = name + '.ply';
            document.getElementById('deleteModal').classList.add('show');
        }
        
        function closeDeleteModal() {
            document.getElementById('deleteModal').classList.remove('show');
            fileToDelete = null;
        }
        
        async function confirmDelete() {
            if (!fileToDelete) return;
            closeDeleteModal();
            showLoading(true, 'Deleting...');
            
            try {
                const response = await fetch(`${API_URL}/api/delete-ply/${fileToDelete}`, { method: 'DELETE' });
                const data = await response.json();
                
                if (data.success) {
                    if (selectedFileName === fileToDelete) {
                        if (currentMesh) scene.remove(currentMesh);
                        currentMesh = null;
                        document.getElementById('infoPanel').style.display = 'none';
                        selectedFileName = null;
                    }
                    await refreshFileList();
                    showError(`✅ ${fileToDelete}.ply deleted!`, false);
                } else {
                    showError('Delete failed: ' + data.error);
                }
            } catch (error) {
                showError('Delete error: ' + error.message);
            } finally {
                showLoading(false);
                fileToDelete = null;
            }
        }
        
        async function loadStorageInfo() {
            try {
                const response = await fetch(`${API_URL}/api/storage-info`);
                const data = await response.json();
                if (data.success && data.storage) {
                    const s = data.storage;
                    document.getElementById('storageInfo').innerHTML = `
                        <div><strong>Google Drive Storage</strong></div>
                        <div style="margin-top: 8px;">${s.used_gb.toFixed(2)} GB / ${s.total_gb.toFixed(2)} GB</div>
                        <div class="progress-bar"><div class="progress-fill" style="width: ${s.used_percentage.toFixed(1)}%"></div></div>
                    `;
                }
            } catch (error) {
                document.getElementById('storageInfo').innerHTML = 'Storage info unavailable';
            }
        }
        
        function refreshFileList() { loadFileList(); loadStorageInfo(); }
        function setProgress(pct) {
            const bar = document.getElementById('uploadProgressBar');
            const fill = document.getElementById('uploadProgressFill');
            const text = document.getElementById('progressText');
            if (pct > 0) {
                bar.style.display = 'block';
                fill.style.width = pct + '%';
                text.textContent = `${Math.round(pct)}%`;
            } else {
                bar.style.display = 'none';
                text.textContent = '';
            }
        }
        
        function showLoading(show, msg = 'Loading...') {
            const loading = document.getElementById('loading');
            const message = document.getElementById('loadingMessage');
            if (show) {
                loading.style.display = 'block';
                message.textContent = msg;
            } else {
                loading.style.display = 'none';
                setProgress(0);
            }
        }
        
        function showError(msg, isError = true) {
            const div = document.getElementById('errorMsg');
            const style = isError ? '' : 'background: #e8f5e9; color: #2e7d32;';
            div.innerHTML = `<div class="error" style="${style}">${msg}</div>`;
            if (!isError) setTimeout(() => div.innerHTML = '', 3000);
        }
        
        function clearError() { document.getElementById('errorMsg').innerHTML = ''; }
        
        // Initialize
        initScene();
        checkConnection().then(conn => { if (conn) refreshFileList(); });
        setInterval(checkConnection, 30000);
        
        document.getElementById('deleteModal').addEventListener('click', function(e) {
            if (e.target === this) closeDeleteModal();
        });
    </script>
</body>
</html>